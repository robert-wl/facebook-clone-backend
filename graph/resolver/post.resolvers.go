package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.49

import (
	"context"
	"encoding/json"
	"fmt"
	"strconv"
	"time"

	"github.com/google/uuid"
	"github.com/yahkerobertkertasnya/facebook-clone-backend/graph"
	"github.com/yahkerobertkertasnya/facebook-clone-backend/graph/model"
)

// LikeCount is the resolver for the likeCount field.
func (r *commentResolver) LikeCount(ctx context.Context, obj *model.Comment) (int, error) {
	var likeCount int64
	if likeCountRedis, err := r.Redis.Get(ctx, fmt.Sprintf("comment:%s:like", obj.ID)).Result(); err != nil {
		likeCount = r.DB.Model(obj).Association("Likes").Count()

		r.Redis.Set(ctx, fmt.Sprintf("comment:%s:like", obj.ID), likeCount, 10*time.Minute)

	} else {
		if likeCountRedis, err := strconv.Atoi(likeCountRedis); err != nil {
			return 0, err
		} else {
			return likeCountRedis, nil
		}
	}

	return int(likeCount), nil
}

// ReplyCount is the resolver for the replyCount field.
func (r *commentResolver) ReplyCount(ctx context.Context, obj *model.Comment) (int, error) {
	var replyCount int64

	if replyCountRedis, err := r.Redis.Get(ctx, fmt.Sprintf("comment:%s:reply", obj.ID)).Result(); err != nil {
		replyCount = r.DB.Model(obj).Association("Comments").Count()

		r.Redis.Set(ctx, fmt.Sprintf("comment:%s:reply", obj.ID), replyCount, 10*time.Minute)

	} else {
		if replyCountRedis, err := strconv.Atoi(replyCountRedis); err != nil {
			return 0, err
		} else {
			return replyCountRedis, nil
		}
	}

	return int(replyCount), nil
}

// Liked is the resolver for the liked field.
func (r *commentResolver) Liked(ctx context.Context, obj *model.Comment) (*bool, error) {
	boolean := false

	userID := ctx.Value("UserID").(string)

	if liked, err := r.Redis.Get(ctx, fmt.Sprintf("comment:%s:like:%s", obj.ID, userID)).Result(); err != nil {
		if err := r.DB.First(&model.CommentLike{}, "comment_id = ? AND user_id = ?", obj.ID, userID).Error; err == nil {
			boolean = true
		}

		r.Redis.Set(ctx, fmt.Sprintf("comment:%s:like:%s", obj.ID, userID), boolean, 10*time.Minute)

	} else {
		if liked == "true" {
			boolean = true
		}
	}

	return &boolean, nil
}

// CreatePost is the resolver for the createPost field.
func (r *mutationResolver) CreatePost(ctx context.Context, newPost model.NewPost) (*model.Post, error) {
	var user *model.User
	userID := ctx.Value("UserID").(string)

	if err := r.DB.First(&user, "id = ?", userID).Error; err != nil {
		return nil, err
	}

	boolVar := false
	post := &model.Post{
		ID:           uuid.NewString(),
		UserID:       userID,
		User:         user,
		Content:      newPost.Content,
		Privacy:      newPost.Privacy,
		LikeCount:    0,
		CommentCount: 0,
		ShareCount:   0,
		GroupID:      newPost.GroupID,
		Files:        newPost.Files,
		Liked:        &boolVar,
		CreatedAt:    time.Now(),
	}

	if err := r.DB.Save(&post).Error; err != nil {
		return nil, err
	}

	for _, vsb := range newPost.Visibility {
		visibility := &model.PostVisibility{
			PostID: post.ID,
			UserID: *vsb,
		}

		if err := r.DB.Save(visibility).Error; err != nil {
			return nil, err
		}
	}

	for i, _ := range newPost.Tags {
		tagModel := &model.PostTag{
			PostID: post.ID,
			UserID: *newPost.Tags[i],
		}

		if err := r.DB.Create(tagModel).Error; err != nil {
			return nil, err
		}
	}

	if err := r.DB.
		Preload("PostTags.User").
		Preload("Visibility.User").
		First(&post).Error; err != nil {
		return nil, err
	}

	go func() {
		var userIDs []string

		subQuery := r.DB.
			Model(&model.Friend{}).
			Where("(sender_id = ? OR receiver_id = ? AND accepted = ?)", userID, userID, true).
			Where("(sender_id = ? OR receiver_id = ? AND accepted = ?)", userID, userID, true).
			Select("DISTINCT CASE WHEN sender_id = ? THEN receiver_id ELSE sender_id END", userID)

		subQueryBlocked := r.DB.
			Model(&model.BlockNotification{}).
			Where("(sender_id = ?)", userID).
			Select("DISTINCT receiver_id")

		if err := r.DB.
			Model(&model.User{}).
			Where("id IN (?) AND id NOT IN (?) AND id != ?", subQuery, subQueryBlocked, userID).
			Select("id").
			Find(&userIDs).Error; err != nil {
			return
		}

		for _, userId := range userIDs {

			newNotification := &model.NewNotification{
				Message: fmt.Sprintf("%s %s posted a new post", user.FirstName, user.LastName),
				UserID:  userId,
				PostID:  &post.ID,
				ReelID:  nil,
				StoryID: nil,
				GroupID: nil,
			}

			if _, err := r.CreateNotification(ctx, *newNotification); err != nil {
				continue
			}
		}
	}()

	return post, nil
}

// CreateComment is the resolver for the createComment field.
func (r *mutationResolver) CreateComment(ctx context.Context, newComment model.NewComment) (*model.Comment, error) {
	var user *model.User
	userID := ctx.Value("UserID").(string)

	if err := r.DB.First(&user, "id = ?", userID).Error; err != nil {
		return nil, err
	}

	boolVar := false
	comment := &model.Comment{
		ID:              uuid.NewString(),
		UserID:          userID,
		User:            user,
		Content:         newComment.Content,
		Liked:           &boolVar,
		LikeCount:       0,
		ReplyCount:      0,
		ParentPostID:    newComment.ParentPost,
		ParentCommentID: newComment.ParentComment,
		CreatedAt:       time.Now(),
	}

	if err := r.DB.Save(&comment).Error; err != nil {
		return nil, err
	}

	go func() {
		var users []*model.User

		subQuery := r.DB.
			Model(&model.Friend{}).
			Where("(sender_id = ? OR receiver_id = ? AND accepted = ?)", userID, userID, true).
			Select("DISTINCT CASE WHEN sender_id = ? THEN receiver_id ELSE sender_id END", userID)

		subQueryBlocked := r.DB.
			Model(&model.BlockNotification{}).
			Where("(sender_id = ?)", userID).
			Select("DISTINCT receiver_id")

		if err := r.DB.Find(&users, "id IN (?) AND id NOT IN (?) AND id != ?", subQuery, subQueryBlocked, userID).Error; err != nil {
			return
		}

		if newComment.ParentPost == nil {
			var comment *model.Comment

			if err := r.DB.First(&comment, "id = ?", newComment.ParentComment).Error; err != nil {
				return
			}

			for _, userDat := range users {

				newNotification := &model.NewNotification{
					Message: fmt.Sprintf("%s %s replied a comment", user.FirstName, user.LastName),
					UserID:  userDat.ID,
					PostID:  comment.ParentPostID,
					ReelID:  nil,
					StoryID: nil,
					GroupID: nil,
				}

				if _, err := r.CreateNotification(ctx, *newNotification); err != nil {
					continue
				}
			}
			r.Redis.Del(ctx, fmt.Sprintf("comment:%s:reply", *newComment.ParentComment))
		} else {
			for _, userDat := range users {

				newNotification := &model.NewNotification{
					Message: fmt.Sprintf("%s %s commented on a post", user.FirstName, user.LastName),
					UserID:  userDat.ID,
					PostID:  newComment.ParentPost,
					ReelID:  nil,
					StoryID: nil,
					GroupID: nil,
				}

				fmt.Println(newNotification)
				if _, err := r.CreateNotification(ctx, *newNotification); err != nil {
					fmt.Println(err)
					continue
				}
			}
			r.Redis.Del(ctx, fmt.Sprintf("post:%s:comment", *newComment.ParentPost))
		}
	}()

	return comment, nil
}

// SharePost is the resolver for the sharePost field.
func (r *mutationResolver) SharePost(ctx context.Context, userID string, postID string) (*string, error) {
	var user *model.User

	if err := r.DB.First(&user, "id = ?", userID).Error; err != nil {
		return nil, err
	}

	conv, err := r.CreateConversation(ctx, user.Username)

	if err != nil {
		return nil, err
	}

	_, err = r.SendMessage(ctx, conv.ID, nil, nil, &postID)

	if err != nil {
		return nil, err
	}

	var post *model.Post

	if err := r.DB.First(&post, "id = ?", postID).Error; err != nil {
		return nil, err
	}

	post.ShareCount = post.ShareCount + 1

	if err := r.DB.Save(&post).Error; err != nil {
		return nil, err
	}

	go func() {

		if err := r.DB.First(&user, "id = ?", userID).Error; err != nil {
			return
		}

		newNotification := &model.NewNotification{
			Message: fmt.Sprintf("%s %s released a new story", user.FirstName, user.LastName),
			UserID:  userID,
			PostID:  &post.ID,
			ReelID:  nil,
			StoryID: nil,
			GroupID: nil,
		}

		if _, err := r.CreateNotification(ctx, *newNotification); err != nil {
			return
		}
	}()

	return &conv.ID, nil
}

// LikePost is the resolver for the likePost field.
func (r *mutationResolver) LikePost(ctx context.Context, postID string) (*model.PostLike, error) {
	var postLike *model.PostLike
	userID := ctx.Value("UserID").(string)

	if err := r.DB.First(&postLike, "post_id = ? AND user_id = ?", postID, userID).Error; err != nil || postLike == nil {
		postLike = &model.PostLike{
			PostID: postID,
			UserID: userID,
		}
		if err := r.DB.Save(&postLike).Error; err != nil {
			return nil, err
		}

		go func() {
			var userIDs []string
			var user *model.User

			if err := r.DB.First(&user, "id = ?", userID).Error; err != nil {
				return
			}

			subQuery := r.DB.
				Model(&model.Friend{}).
				Where("(sender_id = ? OR receiver_id = ? AND accepted = ?)", userID, userID, true).
				Select("DISTINCT CASE WHEN sender_id = ? THEN receiver_id ELSE sender_id END", userID)

			subQueryBlocked := r.DB.
				Model(&model.BlockNotification{}).
				Where("(sender_id = ?)", userID).
				Select("DISTINCT receiver_id")

			if err := r.DB.
				Model(&model.User{}).
				Where("id IN (?) AND id NOT IN (?) AND id != ?", subQuery, subQueryBlocked, userID).
				Select("id").
				Find(&userIDs).Error; err != nil {
				return
			}

			for _, userId := range userIDs {

				newNotification := &model.NewNotification{
					Message: fmt.Sprintf("%s %s liked a post", user.FirstName, user.LastName),
					UserID:  userId,
					PostID:  &postID,
					ReelID:  nil,
					StoryID: nil,
					GroupID: nil,
				}

				if _, err := r.CreateNotification(ctx, *newNotification); err != nil {
					continue
				}
			}
		}()

	} else {
		if err := r.DB.Delete(&postLike).Error; err != nil {
			return nil, err
		}
	}

	r.Redis.Del(ctx, fmt.Sprintf("post:%s:like", postID))
	r.Redis.Del(ctx, fmt.Sprintf("post:%s:like:%s", postID, userID))

	return postLike, nil
}

// Likecomment is the resolver for the likecomment field.
func (r *mutationResolver) Likecomment(ctx context.Context, commentID string) (*model.CommentLike, error) {
	var commentLike *model.CommentLike
	userID := ctx.Value("UserID").(string)

	if err := r.DB.First(&commentLike, "comment_id = ? AND user_id = ?", commentID, userID).Error; err != nil {
		commentLike = &model.CommentLike{
			CommentID: commentID,
			UserID:    userID,
		}
		if err := r.DB.Save(&commentLike).Error; err != nil {
			return nil, err
		}
	} else {
		if err := r.DB.Delete(&commentLike).Error; err != nil {
			return nil, err
		}
	}

	r.Redis.Del(ctx, fmt.Sprintf("comment:%s:like", commentID))
	r.Redis.Del(ctx, fmt.Sprintf("comment:%s:like:%s", commentID, userID))

	return commentLike, nil
}

// DeletePost is the resolver for the deletePost field.
func (r *mutationResolver) DeletePost(ctx context.Context, postID string) (*string, error) {
	if err := r.DB.Delete(&model.Post{}, "id = ?", postID).Error; err != nil {
		return nil, err
	}

	return &postID, nil
}

// LikeCount is the resolver for the likeCount field.
func (r *postResolver) LikeCount(ctx context.Context, obj *model.Post) (int, error) {
	var count int64

	if likeCountRedis, err := r.Redis.Get(ctx, fmt.Sprintf("post:%s:like", obj.ID)).Result(); err != nil {
		if err := r.DB.Find(&model.PostLike{}, "post_id = ?", obj.ID).Count(&count).Error; err != nil {
			return 0, nil
		}

		r.Redis.Set(ctx, fmt.Sprintf("post:%s:like", obj.ID), count, 10*time.Minute)

	} else {
		if likeCountRedis, err := strconv.Atoi(likeCountRedis); err != nil {
			return 0, err
		} else {
			return likeCountRedis, nil
		}
	}

	return int(count), nil
}

// CommentCount is the resolver for the commentCount field.
func (r *postResolver) CommentCount(ctx context.Context, obj *model.Post) (int, error) {
	var commentCount int64

	if commentCountRedis, err := r.Redis.Get(ctx, fmt.Sprintf("post:%s:comment", obj.ID)).Result(); err != nil {
		commentCount = r.DB.Model(obj).Association("Comments").Count()

		r.Redis.Set(ctx, fmt.Sprintf("post:%s:comment", obj.ID), int(commentCount), 10*time.Minute)

	} else {
		if commentCountRedis, err := strconv.Atoi(commentCountRedis); err != nil {
			return 0, err
		} else {
			return commentCountRedis, nil
		}
	}

	return int(commentCount), nil
}

// Group is the resolver for the group field.
func (r *postResolver) Group(ctx context.Context, obj *model.Post) (*model.Group, error) {
	if obj.GroupID == nil {
		return nil, nil
	}

	var group *model.Group

	if groupSerialized, err := r.Redis.Get(ctx, fmt.Sprintf("group:%s", *obj.GroupID)).Result(); err != nil {

		if err := r.DB.
			Find(&group, "id = ?", *obj.GroupID).Error; err != nil {
			return nil, err
		}

		if groupSerialized, err := json.Marshal(group); err != nil {
			return nil, err
		} else {
			r.Redis.Set(ctx, fmt.Sprintf("group:%s", *obj.GroupID), groupSerialized, 10*time.Second)
		}
	} else {
		if err := json.Unmarshal([]byte(groupSerialized), &group); err != nil {
			return nil, err
		}
	}

	return group, nil
}

// Liked is the resolver for the liked field.
func (r *postResolver) Liked(ctx context.Context, obj *model.Post) (*bool, error) {
	boolean := false
	var postLike *model.PostLike

	userID := ctx.Value("UserID").(string)

	if liked, err := r.Redis.Get(ctx, fmt.Sprintf("post:%s:like:%s", obj.ID, userID)).Result(); err != nil {
		if err := r.DB.First(&postLike, "post_id = ? AND user_id = ?", obj.ID, userID).Error; err == nil && postLike != nil {
			boolean = true
		}

		r.Redis.Set(ctx, fmt.Sprintf("post:%s:like:%s", obj.ID, userID), boolean, 10*time.Minute)

	} else {
		if liked == "true" {
			boolean = true
		}
	}

	return &boolean, nil
}

// GetPost is the resolver for the getPost field.
func (r *queryResolver) GetPost(ctx context.Context, id string) (*model.Post, error) {
	panic(fmt.Errorf("not implemented: GetPost - getPost"))
}

// GetPosts is the resolver for the getPosts field.
func (r *queryResolver) GetPosts(ctx context.Context, pagination model.Pagination) ([]*model.Post, error) {
	var posts []*model.Post

	userID := ctx.Value("UserID").(string)

	cacheKeys := []string{"posts", userID, strconv.Itoa(pagination.Start), strconv.Itoa(pagination.Limit)}

	err := r.RedisAdapter.GetOrSet(cacheKeys, &posts, func() (interface{}, error) {
		subQueryFriend := r.DB.
			Select("*").
			Where("(sender_id = ? AND receiver_id = posts.user_id) or (sender_id = posts.user_id AND receiver_id = ?)", userID, userID).
			Table("friends")

		subQueryPrivate := r.DB.
			Select("user_id").
			Where("(post_id = posts.id)").
			Table("post_visibilities")

		subQueryGroup := r.DB.
			Select("group_id").
			Where("user_id = ? AND approved = ?", userID, true).
			Table("members")

		if err := r.DB.
			Order("created_at desc").
			Preload("User").
			Preload("User").
			Preload("Likes").
			Preload("Comments").
			Preload("Visibility.User").
			Preload("PostTags.User").
			Offset(pagination.Start).
			Limit(pagination.Limit).
			Find(&posts, "(privacy = ? OR (privacy = ? AND EXISTS(?)) OR (privacy = ? AND ? IN (?)) OR group_id IN (?))", "public", "friend", subQueryFriend, "specific", userID, subQueryPrivate, subQueryGroup).Error; err != nil {
			return nil, err
		}

		return posts, nil
	}, []string{"posts", userID, strconv.Itoa(pagination.Start), strconv.Itoa(pagination.Limit)}, time.Minute*5)

	if err != nil {
		return nil, err
	}

	return posts, nil
}

// GetGroupPosts is the resolver for the getGroupPosts field.
func (r *queryResolver) GetGroupPosts(ctx context.Context, groupID string, pagination model.Pagination) ([]*model.Post, error) {
	var posts []*model.Post

	if err := r.DB.
		Order("created_at desc").
		Preload("User").
		Preload("Likes").
		Preload("Comments").
		Offset(pagination.Start).
		Limit(pagination.Limit).
		Find(&posts, "group_id = ?", groupID).Error; err != nil {
		return nil, err
	}

	return posts, nil
}

// GetCommentPost is the resolver for the getCommentPost field.
func (r *queryResolver) GetCommentPost(ctx context.Context, postID string) ([]*model.Comment, error) {
	var comments []*model.Comment

	if err := r.DB.
		Preload("User").
		Preload("Likes").
		Preload("Comments").
		Preload("Comments.User").
		Find(&comments, "parent_post_id = ?", postID).Error; err != nil {
		return nil, err
	}

	return comments, nil
}

// GetFilteredPosts is the resolver for the getFilteredPosts field.
func (r *queryResolver) GetFilteredPosts(ctx context.Context, filter string, pagination model.Pagination) ([]*model.Post, error) {
	var posts []*model.Post

	userID := ctx.Value("UserID").(string)

	subQueryFriend := r.DB.
		Select("*").
		Where("(sender_id = ? AND receiver_id = posts.user_id) or (sender_id = posts.user_id AND receiver_id = ?)", userID, userID).
		Table("friends")

	subQueryPrivate := r.DB.
		Select("user_id").
		Where("(post_id = posts.id)").
		Table("post_visibilities")

	subQueryGroup := r.DB.
		Select("group_id").
		Where("user_id = ? AND approved = ?", userID, true).
		Table("members")

	if err := r.DB.
		Order("created_at desc").
		Preload("User").
		Preload("User").
		Preload("Likes").
		Preload("Comments").
		Preload("Visibility.User").
		Preload("PostTags.User").
		Offset(pagination.Start).
		Limit(pagination.Limit).
		Find(&posts, "id = ? OR ((privacy = ? OR (privacy = ? AND EXISTS(?)) OR (privacy = ? AND ? IN (?)) OR group_id IN (?)) AND LOWER(content) LIKE LOWER(?))", filter, "public", "friend", subQueryFriend, "specific", userID, subQueryPrivate, subQueryGroup, "%"+filter+"%").Error; err != nil {
		return nil, err
	}

	//
	return posts, nil
}

// GetGroupHomePosts is the resolver for the getGroupHomePosts field.
func (r *queryResolver) GetGroupHomePosts(ctx context.Context, pagination model.Pagination) ([]*model.Post, error) {
	var posts []*model.Post

	userID := ctx.Value("UserID").(string)

	subQueryGroup := r.DB.
		Select("group_id").
		Where("user_id = ? AND approved = ?", userID, true).
		Table("members")

	if err := r.DB.
		Order("created_at desc").
		Preload("User").
		Preload("User").
		Preload("Likes").
		Preload("Comments").
		Preload("Visibility.User").
		Preload("PostTags.User").
		Offset(pagination.Start).
		Limit(pagination.Limit).
		Find(&posts, "group_id IN (?)", subQueryGroup).Error; err != nil {
		return nil, err
	}

	return posts, nil
}

// Comment returns graph.CommentResolver implementation.
func (r *Resolver) Comment() graph.CommentResolver { return &commentResolver{r} }

// Post returns graph.PostResolver implementation.
func (r *Resolver) Post() graph.PostResolver { return &postResolver{r} }

type commentResolver struct{ *Resolver }
type postResolver struct{ *Resolver }
