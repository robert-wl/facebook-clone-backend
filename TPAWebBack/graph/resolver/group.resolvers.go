package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.36

import (
	"context"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/yahkerobertkertasnya/TPAWebBack/graph"
	"github.com/yahkerobertkertasnya/TPAWebBack/graph/model"
)

// MemberCount is the resolver for the memberCount field.
func (r *groupResolver) MemberCount(ctx context.Context, obj *model.Group) (int, error) {
	return int(r.DB.Model(&obj).Association("Members").Count()), nil
}

// Joined is the resolver for the joined field.
func (r *groupResolver) Joined(ctx context.Context, obj *model.Group) (bool, error) {
	boolVar := false
	var member *model.Member

	userID := ctx.Value("UserID").(string)

	if err := r.DB.First(&member, "group_id = ? AND user_id = ?", obj.ID, userID).Error; err == nil && member != nil {
		boolVar = true
	}

	return boolVar, nil
}

// IsAdmin is the resolver for the isAdmin field.
func (r *groupResolver) IsAdmin(ctx context.Context, obj *model.Group) (bool, error) {
	userID := ctx.Value("UserID").(string)

	if err := r.DB.First(&model.Member{}, "group_id = ? AND user_id = ?", obj.ID, userID).Error; err != nil {
		return false, err
	}

	return true, nil
}

// CreateGroup is the resolver for the createGroup field.
func (r *mutationResolver) CreateGroup(ctx context.Context, group model.NewGroup) (*model.Group, error) {
	userID := ctx.Value("UserID").(string)

	newGroup := &model.Group{
		ID:         uuid.NewString(),
		Name:       group.Name,
		About:      group.About,
		Privacy:    group.Privacy,
		Background: "",
		CreatedAt:  time.Now(),
	}

	if err := r.DB.Save(&newGroup).Error; err != nil {
		return nil, err
	}

	conversation := &model.Conversation{
		ID:      uuid.NewString(),
		GroupID: &newGroup.ID,
	}

	if err := r.DB.Save(&conversation).Error; err != nil {
		return nil, err
	}

	conversationUser := &model.ConversationUsers{
		ConversationID: conversation.ID,
		UserID:         userID,
	}

	if err := r.DB.Save(&conversationUser).Error; err != nil {
		return nil, err
	}

	member := &model.Member{
		GroupID:  newGroup.ID,
		UserID:   userID,
		Approved: true,
		Role:     "Admin",
	}

	if err := r.DB.Save(&member).Error; err != nil {
		return nil, err
	}

	newGroup.ChatID = &conversation.ID

	if err := r.DB.Save(&newGroup).Error; err != nil {
		return nil, err
	}

	if err := r.DB.
		Preload("Members").
		Preload("Members.User").
		Preload("Chat").
		Preload("Files").
		Preload("Files.UploadedBy").
		First(&newGroup).Error; err != nil {
		return nil, err
	}

	return newGroup, nil
}

// GetGroup is the resolver for the getGroup field.
func (r *queryResolver) GetGroup(ctx context.Context, id string) (*model.Group, error) {
	var group *model.Group

	if err := r.DB.
		Preload("Members").
		Preload("Members.User").
		Preload("Chat").
		Preload("Files").
		Preload("Files.UploadedBy").
		Preload("Files.UploadedBy").
		Preload("Posts").
		Preload("Posts.User").
		Find(&group, "id = ? AND privacy = ?", id, "public").Error; err != nil {
		return nil, err
	}

	return group, nil
}

// GetGroupInvite is the resolver for the getGroupInvite field.
func (r *queryResolver) GetGroupInvite(ctx context.Context, id string) ([]*model.User, error) {
	var friendIDs []string
	var friendMemberIDs []string
	var users []*model.User
	userID := ctx.Value("UserID").(string)

	if err := r.DB.
		Model(&model.Friend{}).
		Where("sender_id = ? OR receiver_id = ?", userID, userID).
		Select("DISTINCT CASE WHEN sender_id = ? THEN receiver_id ELSE sender_id END", userID).
		Find(&friendIDs).Error; err != nil {
		return nil, err
	}

	if err := r.DB.
		Model(&model.Member{}).
		Where("group_id = ? AND user_id IN (?)", id, friendIDs).
		Select("user_id").
		Find(&friendMemberIDs).Error; err != nil {
		return nil, err
	}

	fmt.Println(friendIDs)
	fmt.Println(friendMemberIDs)

	if len(friendMemberIDs) != 0 {
		if err := r.DB.Find(&users, "id IN (?) AND id NOT IN (?)", friendIDs, friendMemberIDs).Error; err != nil {
			return nil, err
		}
	} else {
		if err := r.DB.Find(&users, "id IN (?)", friendIDs).Error; err != nil {
			return nil, err
		}
	}

	fmt.Println(users)

	return users, nil
}

// GetGroups is the resolver for the getGroups field.
func (r *queryResolver) GetGroups(ctx context.Context) ([]*model.Group, error) {
	var groups []*model.Group

	if err := r.DB.Find(&groups, "privacy = ?", "public").Error; err != nil {
		return nil, err
	}

	return groups, nil
}

// GetJoinedGroups is the resolver for the getJoinedGroups field.
func (r *queryResolver) GetJoinedGroups(ctx context.Context) ([]*model.Group, error) {
	var groupIDs []*string
	var groups []*model.Group

	userID := ctx.Value("UserID").(string)

	if err := r.DB.Model(&model.Member{}).Where("user_id = ?", userID).Select("group_id").Find(&groupIDs).Error; err != nil {
		return nil, err
	}

	if err := r.DB.Find(&groups, "id in (?)", groupIDs).Error; err != nil {
		return nil, err
	}

	return groups, nil
}

// Group returns graph.GroupResolver implementation.
func (r *Resolver) Group() graph.GroupResolver { return &groupResolver{r} }

type groupResolver struct{ *Resolver }
