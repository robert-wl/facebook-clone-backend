package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.36

import (
	"context"
	"fmt"
	"strings"
	"time"

	"github.com/google/uuid"
	"github.com/yahkerobertkertasnya/TPAWebBack/graph"
	"github.com/yahkerobertkertasnya/TPAWebBack/graph/model"
)

// MemberCount is the resolver for the memberCount field.
func (r *groupResolver) MemberCount(ctx context.Context, obj *model.Group) (int, error) {
	return int(r.DB.Model(&obj).Association("Members").Count()), nil
}

// Joined is the resolver for the joined field.
func (r *groupResolver) Joined(ctx context.Context, obj *model.Group) (string, error) {
	status := "not joined"
	var member *model.Member

	userID := ctx.Value("UserID").(string)

	if err := r.DB.First(&member, "group_id = ? AND user_id = ?", obj.ID, userID).Error; err == nil && member != nil {
		if member.Requested && member.Approved {
			status = "pending"
		} else if member.Approved {
			status = "joined"
		} else {
			status = "not accepted"
		}
	}

	return status, nil
}

// IsAdmin is the resolver for the isAdmin field.
func (r *groupResolver) IsAdmin(ctx context.Context, obj *model.Group) (bool, error) {
	userID := ctx.Value("UserID").(string)

	if err := r.DB.First(&model.Member{}, "group_id = ? AND user_id = ? and role = ?", obj.ID, userID, "Admin").Error; err != nil {
		return false, nil
	}

	return true, nil
}

// CreateGroup is the resolver for the createGroup field.
func (r *mutationResolver) CreateGroup(ctx context.Context, group model.NewGroup) (*model.Group, error) {
	userID := ctx.Value("UserID").(string)

	newGroup := &model.Group{
		ID:         uuid.NewString(),
		Name:       group.Name,
		About:      group.About,
		Privacy:    group.Privacy,
		Background: "",
		CreatedAt:  time.Now(),
	}

	if err := r.DB.Save(&newGroup).Error; err != nil {
		return nil, err
	}

	conversation := &model.Conversation{
		ID:      uuid.NewString(),
		GroupID: &newGroup.ID,
	}

	if err := r.DB.Save(&conversation).Error; err != nil {
		return nil, err
	}

	conversationUser := &model.ConversationUsers{
		ConversationID: conversation.ID,
		UserID:         userID,
	}

	if err := r.DB.Save(&conversationUser).Error; err != nil {
		return nil, err
	}

	member := &model.Member{
		GroupID:  newGroup.ID,
		UserID:   userID,
		Approved: true,
		Role:     "Admin",
	}

	if err := r.DB.Save(&member).Error; err != nil {
		return nil, err
	}

	newGroup.ChatID = &conversation.ID

	if err := r.DB.Save(&newGroup).Error; err != nil {
		return nil, err
	}

	if err := r.DB.
		Preload("Members").
		Preload("Members.User").
		Preload("Chat").
		Preload("Files").
		Preload("Files.UploadedBy").
		First(&newGroup).Error; err != nil {
		return nil, err
	}

	return newGroup, nil
}

// InviteToGroup is the resolver for the inviteToGroup field.
func (r *mutationResolver) InviteToGroup(ctx context.Context, groupID string, userID string) (*model.Member, error) {
	member := &model.Member{
		GroupID:   groupID,
		UserID:    userID,
		Approved:  false,
		Role:      "member",
		Requested: false,
	}

	if err := r.DB.Save(&member).Error; err != nil {
		return nil, err
	}

	//TODO ADD NOTIFICATION

	return member, nil
}

// HandleRequest is the resolver for the handleRequest field.
func (r *mutationResolver) HandleRequest(ctx context.Context, groupID string) (*model.Member, error) {
	userID := ctx.Value("UserID").(string)
	var member *model.Member

	if err := r.DB.First(&member, "group_id = ? AND user_id = ?", groupID, userID).Error; err != nil {
		member = &model.Member{
			GroupID:   groupID,
			UserID:    userID,
			Requested: true,
			Approved:  false,
			Role:      "member",
		}

		if err := r.DB.Save(&member).Error; err != nil {
			return nil, err
		}

		return member, nil
	}

	if member.Approved == false {
		member.Requested = false
		member.Approved = true

		if err := r.DB.Save(&member).Error; err != nil {
			return nil, err
		}

		var group *model.Group

		if err := r.DB.First(&group, "id = ?", groupID).Error; err != nil {
			return nil, err
		}

		conversationUser := &model.ConversationUsers{
			ConversationID: *group.ChatID,
			UserID:         member.UserID,
		}

		if err := r.DB.Save(&conversationUser).Error; err != nil {
			return nil, err
		}

		return member, nil
	}

	if err := r.DB.Delete(&member).Error; err != nil {
		return nil, err
	}

	//TODO ADD NOTIFICATION

	return member, nil
}

// UpdateGroupBackground is the resolver for the updateGroupBackground field.
func (r *mutationResolver) UpdateGroupBackground(ctx context.Context, groupID string, background string) (*model.Group, error) {
	var group *model.Group

	if err := r.DB.First(&group, "id = ?", groupID).Update("background", background).Error; err != nil {
		return nil, err
	}

	return group, nil
}

// UploadFile is the resolver for the uploadFile field.
func (r *mutationResolver) UploadFile(ctx context.Context, groupID string, file model.NewGroupFile) (*model.GroupFile, error) {
	userID := ctx.Value("UserID").(string)

	newFile := &model.GroupFile{
		ID:         uuid.NewString(),
		GroupID:    groupID,
		Name:       file.Name,
		Type:       file.Type,
		URL:        file.URL,
		UserID:     userID,
		UploadedAt: time.Now(),
	}

	var fileCount int64
	count := 0

	for {
		if err := r.DB.Find(&model.GroupFile{}, "group_id = ? AND name = ? AND type = ?", newFile.GroupID, newFile.Name, newFile.Type).Count(&fileCount).Error; err != nil {
			break
		}

		fmt.Println(fileCount)
		fmt.Println(newFile.Name)

		if fileCount == 0 {
			break
		}

		count++
		split := strings.Split(file.Name, ".")

		fmt.Println(split)
		if len(split) >= 2 {
			newFile.Name = strings.Join(split[:len(split)-1], "") + fmt.Sprintf(" (%d)", count) + "." + split[len(split)-1]
		} else {
			newFile.Name = fmt.Sprintf("%s (%d)", file.Name, count)
		}
	}

	if err := r.DB.Save(&newFile).Error; err != nil {
		return nil, err
	}

	return newFile, nil
}

// DeleteFile is the resolver for the deleteFile field.
func (r *mutationResolver) DeleteFile(ctx context.Context, fileID string) (*bool, error) {
	boolean := true
	if err := r.DB.Delete(&model.GroupFile{}, "id = ?", fileID).Error; err != nil {
		boolean = false
		return &boolean, err
	}

	return &boolean, nil
}

// ApproveMember is the resolver for the approveMember field.
func (r *mutationResolver) ApproveMember(ctx context.Context, groupID string, userID string) (*model.Member, error) {
	var member *model.Member

	if err := r.DB.First(&member, "group_id = ? AND user_id = ?", groupID, userID).Update("approved", true).Update("requested", false).Error; err != nil {
		return nil, err
	}

	return member, nil
}

// DenyMember is the resolver for the denyMember field.
func (r *mutationResolver) DenyMember(ctx context.Context, groupID string, userID string) (*model.Member, error) {
	var member *model.Member

	if err := r.DB.Delete(&member, "group_id = ? AND user_id = ?", groupID, userID).Error; err != nil {
		return nil, err
	}

	return member, nil
}

// KickMember is the resolver for the kickMember field.
func (r *mutationResolver) KickMember(ctx context.Context, groupID string, userID string) (*bool, error) {
	boolean := true
	if err := r.DB.Delete(&model.Member{}, "group_id = ? AND user_id = ?", groupID, userID).Error; err != nil {
		boolean = false
		return &boolean, err
	}

	return &boolean, nil
}

// LeaveGroup is the resolver for the leaveGroup field.
func (r *mutationResolver) LeaveGroup(ctx context.Context, groupID string) (*bool, error) {
	userID := ctx.Value("UserID").(string)
	boolean := true
	if err := r.DB.Delete(&model.Member{}, "group_id = ? AND user_id = ?", groupID, userID).Error; err != nil {
		boolean = false
		return &boolean, err
	}

	return &boolean, nil
}

// PromoteMember is the resolver for the promoteMember field.
func (r *mutationResolver) PromoteMember(ctx context.Context, groupID string, userID string) (*model.Member, error) {
	var member *model.Member

	if err := r.DB.First(&member, "group_id = ? AND user_id = ?", groupID, userID).Update("role", "Admin").Error; err != nil {
		return nil, err
	}

	return member, nil
}

// GetGroup is the resolver for the getGroup field.
func (r *queryResolver) GetGroup(ctx context.Context, id string) (*model.Group, error) {
	var group *model.Group

	if err := r.DB.
		Preload("Members").
		Preload("Members.User").
		Preload("Chat").
		Preload("Files").
		Preload("Files.UploadedBy").
		Preload("Posts").
		Preload("Posts.User").
		Find(&group, "id = ? AND privacy = ?", id, "public").Error; err != nil {
		return nil, err
	}

	return group, nil
}

// GetGroupInvite is the resolver for the getGroupInvite field.
func (r *queryResolver) GetGroupInvite(ctx context.Context, id string) ([]*model.User, error) {
	var friendIDs []string
	var friendMemberIDs []string
	var users []*model.User
	userID := ctx.Value("UserID").(string)

	if err := r.DB.
		Model(&model.Friend{}).
		Where("sender_id = ? OR receiver_id = ?", userID, userID).
		Select("DISTINCT CASE WHEN sender_id = ? THEN receiver_id ELSE sender_id END", userID).
		Find(&friendIDs).Error; err != nil {
		return nil, err
	}

	if err := r.DB.
		Model(&model.Member{}).
		Where("group_id = ? AND user_id IN (?)", id, friendIDs).
		Select("user_id").
		Find(&friendMemberIDs).Error; err != nil {
		return nil, err
	}

	if len(friendMemberIDs) != 0 {
		if err := r.DB.Find(&users, "id IN (?) AND id NOT IN (?)", friendIDs, friendMemberIDs).Error; err != nil {
			return nil, err
		}
	} else {
		if err := r.DB.Find(&users, "id IN (?)", friendIDs).Error; err != nil {
			return nil, err
		}
	}

	return users, nil
}

// GetGroups is the resolver for the getGroups field.
func (r *queryResolver) GetGroups(ctx context.Context) ([]*model.Group, error) {
	var groups []*model.Group

	if err := r.DB.Find(&groups, "privacy = ?", "public").Error; err != nil {
		return nil, err
	}

	return groups, nil
}

// GetJoinedGroups is the resolver for the getJoinedGroups field.
func (r *queryResolver) GetJoinedGroups(ctx context.Context) ([]*model.Group, error) {
	var groupIDs []*string
	var groups []*model.Group

	userID := ctx.Value("UserID").(string)

	if err := r.DB.Model(&model.Member{}).Where("user_id = ?", userID).Select("group_id").Find(&groupIDs).Error; err != nil {
		return nil, err
	}

	if err := r.DB.Preload("Chat").Find(&groups, "id in (?)", groupIDs).Error; err != nil {
		return nil, err
	}

	return groups, nil
}

// GetGroupFiles is the resolver for the getGroupFiles field.
func (r *queryResolver) GetGroupFiles(ctx context.Context, groupID string) ([]*model.GroupFile, error) {
	var files []*model.GroupFile

	if err := r.DB.
		Order("uploaded_at ASC").
		Preload("UploadedBy").
		Find(&files, "group_id = ?", groupID).Error; err != nil {
		return nil, err
	}

	return files, nil
}

// GetJoinRequests is the resolver for the getJoinRequests field.
func (r *queryResolver) GetJoinRequests(ctx context.Context, groupID string) ([]*model.Member, error) {
	var members []*model.Member

	if err := r.DB.Preload("User").
		Find(&members, "group_id = ? AND requested = ? AND approved = ?", groupID, true, false).Error; err != nil {
		return nil, err
	}

	return members, nil
}

// Group returns graph.GroupResolver implementation.
func (r *Resolver) Group() graph.GroupResolver { return &groupResolver{r} }

type groupResolver struct{ *Resolver }
